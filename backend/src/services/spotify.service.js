const { spawn, exec } = require('child_process');
const { GoogleGenAI } = require('@google/genai');
const { getData, getDetails } = require('spotify-url-info')(fetch);
const { COMMON_ARGS, CACHE_DIR, getVideoInfo } = require('./ytdlp.service');

// 2026 Standard Initialization
const client = process.env.GEMINI_API_KEY && process.env.GEMINI_API_KEY !== 'YOUR_GEMINI_API_KEY_HERE' 
    ? new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY }) 
    : null;

const aiCache = new Map();

// Circuit Breaker for Quota Limits
let isGemini3Blocked = false;
let gemini3BlockTime = 0;
const BLOCK_DURATION = 60 * 60 * 1000; // 1 hour

async function fetchIsrcFromDeezer(title, artist) {
    try {
        // Step 1: Strict Search
        let query = `artist:"${artist}" track:"${title}"`;
        let searchUrl = `https://api.deezer.com/search?q=${encodeURIComponent(query)}`;
        let res = await fetch(searchUrl);
        let searchData = await res.json();

        // Step 2: Loose Search
        if (!searchData.data || searchData.data.length === 0) {
             query = `${title} ${artist}`;
             searchUrl = `https://api.deezer.com/search?q=${encodeURIComponent(query)}`;
             res = await fetch(searchUrl);
             searchData = await res.json();
        }

        // Step 3: Clean Artist Search
        if (!searchData.data || searchData.data.length === 0) {
            const cleanArtist = artist.replace(/\s+(Music|Band|Official|Topic|TV)\s*$/i, '').trim();
            if (cleanArtist !== artist) {
                query = `artist:"${cleanArtist}" track:"${title}"`;
                searchUrl = `https://api.deezer.com/search?q=${encodeURIComponent(query)}`;
                res = await fetch(searchUrl);
                searchData = await res.json();
            }
        }

        if (searchData.data && searchData.data.length > 0) {
            const trackId = searchData.data[0].id;
            const detailRes = await fetch(`https://api.deezer.com/track/${trackId}`);
            const detailData = await detailRes.json();
            return detailData.isrc || null;
        }
    } catch (err) {
        console.error('[Deezer] ISRC fetch failed:', err.message);
    }
    return null;
}

async function fetchIsrcFromItunes(title, artist) {
    try {
        const query = `${title} ${artist}`;
        const searchUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(query)}&limit=5&entity=song`;
        const res = await fetch(searchUrl);
        const data = await res.json();

        if (data.results && data.results.length > 0) {
            const match = data.results[0];
            return match.isrc || null;
        }
    } catch (err) {
        console.error('[iTunes] ISRC fetch failed:', err.message);
    }
    return null;
}

async function refineSearchWithAI(metadata) {
    const { title, artist, album, year, isrc, duration } = metadata;
    const cacheKey = `${title}-${artist}`.toLowerCase();
    if (aiCache.has(cacheKey)) return aiCache.get(cacheKey);

    const promptText = `Act as a Professional Music Query Architect.
        DATA: Title: "${title}", Artist: "${artist}", Album: "${album}", Year: "${year}", VERIFIED_ISRC: "${isrc || 'NONE'}", Duration: ${Math.round(duration / 1000)}s
        
        TASK:
        1. Create a high-precision YouTube search query.
        2. If VERIFIED_ISRC is provided, include it in the query.
        3. If VERIFIED_ISRC is "NONE", DO NOT invent one. Instead, use Artist, Title, and Album.
        4. Append professional keywords like "Topic", "Official Audio", or "Auto-generated by YouTube" to prioritize official label uploads over music videos with intros.
        5. Aim to find the STUDIO version that matches the duration exactly.

        RETURN JSON ONLY: {"query": "Artist Title [ISRC] Topic", "confidence": 100}`;

    // STRATEGY 1: Groq (Llama 3.3 70B) - Ultra Fast Primary
    if (process.env.GROQ_API_KEY) {
        try {
            console.log('[AI] Attempting Groq (Llama 3.3)...');
            const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${process.env.GROQ_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'llama-3.3-70b-versatile',
                    messages: [{ role: 'user', content: promptText }],
                    response_format: { type: 'json_object' }
                })
            });

            if (response.ok) {
                const data = await response.json();
                const parsed = JSON.parse(data.choices[0].message.content);
                console.log(`[AI] Groq successful. Query: "${parsed.query}" | Confidence: ${parsed.confidence}%`);
                aiCache.set(cacheKey, parsed);
                return parsed;
            } else {
                console.warn(`[AI] Groq failed: ${response.status} ${response.statusText}`);
            }
        } catch (err) {
            console.warn('[AI] Groq error:', err.message);
        }
    }

    // STRATEGY 2: Gemini - Reliable Fallback
    if (client) {
        console.log('[AI] Falling back to Gemini...');
        let modelsToTry = ["gemini-3-flash-preview", "gemini-2.5-flash-lite", "gemini-2.0-flash-latest"];
        
        if (isGemini3Blocked && (Date.now() - gemini3BlockTime < BLOCK_DURATION)) {
            modelsToTry = ["gemini-2.5-flash-lite", "gemini-2.0-flash-latest"];
        } else {
            isGemini3Blocked = false; 
        }
        
        for (const modelName of modelsToTry) {
            try {
                const response = await client.models.generateContent({
                    model: modelName,
                    contents: [{ role: 'user', parts: [{ text: promptText }] }]
                });

                const responseText = response.text || (typeof response.text === 'function' ? response.text() : '');
                if (!responseText) throw new Error('Empty AI response');

                const text = responseText.trim().replace(/```json|```/g, '');
                const parsed = JSON.parse(text);
                
                console.log(`[AI] Gemini (${modelName}) successful. Query: "${parsed.query}" | Confidence: ${parsed.confidence}%`);
                aiCache.set(cacheKey, parsed);
                return parsed;
            } catch (error) {
                if (error.message.includes('429') && modelName.includes('gemini-3')) {
                    isGemini3Blocked = true;
                    gemini3BlockTime = Date.now();
                    console.warn('[AI] Gemini 3 quota hit. Switching to lite models.');
                }
            }
        }
    }

    return { query: null, confidence: 0 };
}

async function fetchFromOdesli(spotifyUrl) {
    try {
        const url = `https://api.odesli.co/v1-alpha.1/links?url=${encodeURIComponent(spotifyUrl)}`;
        const res = await fetch(url);
        if (!res.ok) return null;
        const data = await res.json();

        const youtubeLink = data.linksByPlatform?.youtube?.url || data.linksByPlatform?.youtubeMusic?.url;
        if (!youtubeLink) return null;

        const entityId = data.linksByPlatform?.youtube?.entityUniqueId || data.linksByPlatform?.youtubeMusic?.entityUniqueId;
        const entity = data.entitiesByUniqueId[entityId];

        return {
            targetUrl: youtubeLink,
            title: entity?.title,
            artist: entity?.artistName,
            thumbnailUrl: entity?.thumbnailUrl
        };
    } catch (err) {
        console.error('[Odesli] Lookup failed:', err.message);
        return null;
    }
}

async function resolveSpotifyToYoutube(videoURL, cookieArgs = [], onProgress = () => {}) {
    if (!videoURL.includes('spotify.com')) return { targetUrl: videoURL };

    try {
        onProgress('fetching_info', 10, { subStatus: 'Accessing Spotify Metadata...' });
        
        // 1. Fetch Spotify Metadata FIRST (The "Truth")
        // STRATEGY A: "getData" - Scrapes the internal __NEXT_DATA__ for exact JSON metadata (Most Reliable for Duration)
        let details = null;
        try {
            details = await getData(videoURL);
        } catch (e) {
            console.warn('[Spotify] Primary "getData" fetch failed, trying fallbacks...');
        }

        // STRATEGY B: "getDetails" - Scrapes OpenGraph/OEmbed tags (Good for Titles, sometimes missing Duration)
        if (!details) {
            try {
                details = await getDetails(videoURL);
            } catch (e) {
                console.warn('[Spotify] Secondary "getDetails" fallback failed.');
            }
        }

        // STRATEGY C: Official OEmbed API - Guaranteed basic info (Title/Cover) but often no Duration
        if (!details || !details.title && !details.name) {
             try {
                const oembedRes = await fetch(`https://open.spotify.com/oembed?url=${encodeURIComponent(videoURL)}`);
                const oembedData = await oembedRes.json();
                if (oembedData) {
                    details = {
                        name: oembedData.title,
                        artists: [{ name: 'Unknown Artist' }],
                        coverArt: { sources: [{ url: oembedData.thumbnail_url }] }
                    };
                }
             } catch (e) {
                 console.warn('[Spotify] OEmbed fallback failed.');
             }
        }

        if (!details) throw new Error('Spotify metadata fetch failed');

        // Normalize Data from different strategies
        const metadata = {
            title: details.name || details.preview?.title || details.title || 'Unknown Title',
            artist: (details.artists && details.artists[0]?.name) || details.preview?.artist || details.artist || 'Unknown Artist',
            album: (details.album && details.album.name) || details.preview?.album || details.album || '',
            imageUrl: (details.visualIdentity?.image && details.visualIdentity.image[details.visualIdentity.image.length - 1]?.url) || 
                      (details.coverArt?.sources && details.coverArt.sources[details.coverArt.sources.length - 1]?.url) || 
                      details.preview?.image || details.image || details.thumbnail_url || '',
            duration: details.duration_ms || details.duration || details.preview?.duration_ms || 0,
            year: (typeof details.releaseDate === 'string' && details.releaseDate.split('-')[0]) || (typeof details.release_date === 'string' && details.release_date.split('-')[0]) || 'Unknown',
            isrc: details.external_ids?.isrc || details.isrc || details.preview?.isrc || ''
        };

        // STRATEGY 0: Odesli (Songlink)
        onProgress('fetching_info', 15, { subStatus: 'Querying Odesli Global Database...' });
        console.log(`[Spotify] Attempting Odesli resolution...`);
        const odesliResult = await fetchFromOdesli(videoURL);
        
        if (odesliResult) {
            console.log(`[Spotify] Odesli found: ${odesliResult.targetUrl}`);
            onProgress('fetching_info', 20, { subStatus: 'Verifying Odesli Match Duration...' });
            
            try {
                // Verify Duration Match
                const ytInfo = await getVideoInfo(odesliResult.targetUrl, cookieArgs);
                const ytDurationMs = (ytInfo.duration || 0) * 1000;
                const diff = Math.abs(metadata.duration - ytDurationMs);
                
                // Tolerance: 15 seconds (handles minor silence/intro differences)
                // FAIL-SAFE: If Spotify duration is 0 (missing), we trust Odesli to avoid discarding valid links.
                if (metadata.duration === 0 || diff < 15000) {
                    if (metadata.duration === 0) {
                         console.log(`[Spotify] Duration missing (0ms). Trusting Odesli match automatically.`);
                    } else {
                         console.log(`[Spotify] Duration Match! Delta: ${diff}ms`);
                    }
                    onProgress('fetching_info', 30, { subStatus: 'Perfect Match Confirmed.' });
                    return {
                        ...metadata,
                        targetUrl: odesliResult.targetUrl,
                        imageUrl: odesliResult.thumbnailUrl || metadata.imageUrl
                    };
                } else {
                    console.warn(`[Spotify] Duration Mismatch! Spotify: ${metadata.duration}ms vs YouTube: ${ytDurationMs}ms. Delta: ${diff}ms`);
                    console.warn(`[Spotify] Discarding Odesli result. Falling back to strict search.`);
                    onProgress('fetching_info', 25, { subStatus: 'Duration mismatch detected. Retrying...' });
                }
            } catch (verErr) {
                console.warn(`[Spotify] Could not verify Odesli video: ${verErr.message}`);
            }
        } else {
            console.log(`[Spotify] Odesli failed, falling back to manual resolution...`);
        }

        // STRATEGY 1: ISRC Resolution
        if (!metadata.isrc) {
            onProgress('fetching_info', 35, { subStatus: 'Resolving ISRC via Deezer/iTunes...' });
            let foundIsrc = await fetchIsrcFromDeezer(metadata.title, metadata.artist);
            
            if (!foundIsrc) {
                 foundIsrc = await fetchIsrcFromItunes(metadata.title, metadata.artist);
            }

            if (foundIsrc) {
                metadata.isrc = foundIsrc;
                onProgress('fetching_info', 40, { subStatus: `ISRC Found: ${foundIsrc}` });
            }
        }

        if (metadata.isrc) {
            onProgress('fetching_info', 45, { subStatus: 'Scanning YouTube for ISRC Match...' });
            // Strict duration check for ISRC matches too, just in case
            const isrcUrl = await searchOnYoutube(`"${metadata.isrc}"`, cookieArgs, metadata.duration);
            if (isrcUrl) {
                return { ...metadata, targetUrl: isrcUrl };
            }
        }

        // STRATEGY 2: AI + Text Search
        onProgress('fetching_info', 55, { subStatus: 'Initializing AI Query Architect...' });
        const aiPromise = refineSearchWithAI(metadata);
        
        const cleanArtist = metadata.artist.replace(/\s+(Music|Band|Official|Topic|TV)\s*$/i, '').trim();
        
        // Strategy A: Clean Title + Artist (The most reliable for obscure tracks)
        const cleanSearchPromise = searchOnYoutube(`${metadata.title} ${cleanArtist}`, cookieArgs, metadata.duration);
        
        // Strategy B: AI Optimized Query
        const [aiResult, cleanUrl] = await Promise.all([aiPromise, cleanSearchPromise]);
        
        onProgress('fetching_info', 75, { subStatus: 'Filtering Search Results...' });
        
        let finalUrl = cleanUrl; // Prioritize the clean search result if it works
        
        if (!finalUrl && aiResult && aiResult.query) {
            finalUrl = await searchOnYoutube(aiResult.query, cookieArgs, metadata.duration);
        }

        if (!finalUrl) {
            onProgress('fetching_info', 85, { subStatus: 'Deep scanning YouTube (Last Resort)...' });
            // Last Resort: Title + Artist + Audio
            finalUrl = await searchOnYoutube(`${metadata.title} ${metadata.artist} audio`, cookieArgs, metadata.duration);
        }
        
        if (!finalUrl) throw new Error('Could not find matching video.');

        return {
            ...metadata,
            targetUrl: finalUrl,
            isrc: metadata.isrc || ''
        };
        
    } catch (err) {
        console.error('[Spotify] Resolution failed:', err.message);
        throw err;
    }
}

async function searchOnYoutube(query, cookieArgs, targetDurationMs = 0) {
    const cleanQuery = query.replace(/on Spotify/g, '').replace(/-/g, ' ').trim();
    
    // web_safari and android_vr are currently most reliable for high quality without PO Token.
    const clientArg = 'youtube:player_client=web_safari,android_vr,tv';

    const args = [
        ...cookieArgs,
        '--get-id',
        ...COMMON_ARGS,
        '--extractor-args', `${clientArg}`,
        '--cache-dir', CACHE_DIR,
    ];

    // Insert match filter if we have a duration
    if (targetDurationMs > 0) {
        // Increase tolerance to 20 seconds for better matching with official videos
        const minDur = Math.round(targetDurationMs / 1000) - 20;
        const maxDur = Math.round(targetDurationMs / 1000) + 20;
        args.push('--match-filter', `duration > ${minDur} & duration < ${maxDur}`);
    }

    args.push(`ytsearch10:${cleanQuery}`);

    console.log(`[YouTube Search] Executing: ${cleanQuery} (Tolerance: ${targetDurationMs > 0 ? 'Â±20s' : 'OFF'})`);
    const searchProcess = spawn('yt-dlp', args);
    
    let youtubeId = '';
    let errorLog = '';

    await new Promise((resolve) => {
        searchProcess.stdout.on('data', (data) => youtubeId += data.toString());
        searchProcess.stderr.on('data', (data) => errorLog += data.toString());
        searchProcess.on('close', resolve);
    });

    if (youtubeId.trim()) {
        const id = youtubeId.trim().split('\n')[0];
        console.log(`[YouTube Search] Match Found: ${id}`);
        return `https://www.youtube.com/watch?v=${id}`;
    }
    
    console.warn(`[YouTube Search] No match found for: ${cleanQuery}`);
    if (errorLog && !errorLog.includes('does not pass filter')) console.warn(`[yt-dlp Search Error] ${errorLog}`);
    return null;
}

module.exports = { resolveSpotifyToYoutube, fetchIsrcFromDeezer };